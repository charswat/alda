{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "#librerias\n",
    "import random, sys, math, datetime,time"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Camino:  [0, 10, 9, 6, 7, 4, 8, 5, 19, 17, 3, 2, 14, 11, 1, 18, 15, 12, 13, 16, 0]\n",
      "Costo del camino:  580.9428999999999\n"
     ]
    }
   ],
   "source": [
    "class TSPTW:\n",
    "    # Elige un paso para una hormiga, teniendo en cuenta los valores\n",
    "    # las feromonas y descartando los nodos ya visitados.\n",
    "    def eligeNodo(valors, ferom, visitados,time_constraints):\n",
    "        #Se calcula la tabla de pesos de cada ciudad\n",
    "        listaValores  = []\n",
    "        disponibles = []\n",
    "        actual      = visitados[-1]\n",
    "    \n",
    "        # Influencia de cada valor (alfa: feromonas; beta: valor)\n",
    "        alfa = 1.0\n",
    "        beta = 0.5\n",
    "        constraints = time_constraints\n",
    "        # El parámetro beta (peso de los valores) es 0.5 y alfa=1.0\n",
    "        for i in range(len(valors)):\n",
    "            if i not in visitados:\n",
    "                #print(\"aqui\",valors[actual][i])\n",
    "                fer  = math.pow((1.0 + ferom[actual][i]), alfa)\n",
    "                peso = math.pow(1.0/valors[actual][i], beta) * fer\n",
    "                disponibles.append(i)\n",
    "                listaValores.append(peso)\n",
    "    \n",
    "        # Se elige aleatoriamente una de los nodos disponibles,\n",
    "        # teniendo en cuenta su peso relativo.\n",
    "        valor     = random.random() * sum(listaValores)\n",
    "        acumulado = 0.0\n",
    "        i         = -1\n",
    "        while valor > acumulado:\n",
    "            i         += 1\n",
    "            acumulado += listaValores[i]        \n",
    "        return disponibles[i]\n",
    "    \n",
    "    # Genera una \" hormiga \" , que eligirá un camino (nodos que visita) teniendo en cuenta\n",
    "    # los valores y los rastros de feromonas. Devuelve una tupla\n",
    "    # con el camino (nodos visitados) y su longCamino (Suma de valores).\n",
    "    def eligeCamino(matriz, feromonas,time_constraints):\n",
    "        # El nodo inicial siempre es el 0\n",
    "        camino     = [0]\n",
    "        longCamino = 0\n",
    "    \n",
    "        # Elegir cada paso según los valores y las feromonas\n",
    "        while len(camino) < len(matriz):\n",
    "            nodo      = eligeNodo(matriz, feromonas, camino,time_constraints)\n",
    "            longCamino += matriz[camino[-1]][nodo]\n",
    "            camino.append(nodo)\n",
    "            #print(longCamino)\n",
    "        # Para terminar hay que volver al nodo de origen (0)\n",
    "        longCamino += matriz [camino[-1]][0]\n",
    "        camino.append(0)\n",
    "    \n",
    "        return (camino, longCamino)\n",
    "    \n",
    "    # Actualiza la matriz de feromonas siguiendo el camino recibido\n",
    "    def rastroFeromonas(feromonas, camino, dosis):\n",
    "           for i in range (len(camino) - 1):\n",
    "                 feromonas[camino[i]][camino[i+1]] += dosis\n",
    "    \n",
    "    # Evapora todas las feromonas multiplicándolas por una constante\n",
    "    # = 0.9 ( en otras palabras, el coefienciente de evaporación es 0.1)\n",
    "    def evaporaFeromonas(feromonas):     \n",
    "           for lista in feromonas:\n",
    "            for i in range(len(lista)):\n",
    "                lista[i] *= 0.9\n",
    "    \n",
    "    \n",
    "    # Resuelve el problema del viajante de comercio mediante el\n",
    "    # alforitmo de la colonia de hormigas. Recibe una matriz de\n",
    "    # distancias y devuelve una tupla con el mejor camino que ha \n",
    "    # obtenido (lista de índices) y su longitud\n",
    "    def hormigas(matriz, iteraciones, distMedia,time_constraints):\n",
    "        # Primero se crea una matriz de feromonas vacía\n",
    "        n = len(matriz)\n",
    "        feromonas = [[0 for i in range(n)] for j in range(n)]\n",
    "        \n",
    "        # El mejor camino y su longitud (inicialmente \"infinita\")\n",
    "        mejorCamino     = []\n",
    "        longMejorCamino = sys.maxsize\n",
    "        \n",
    "        # En cada iteración se genera una hormiga, que elige una camino,\n",
    "        # y si es mejor que el mejor que teníamos, deja su rastro de\n",
    "        # feromonas (mayor cuanto más corto sea el camino)\n",
    "        for iter in range(iteraciones):\n",
    "            (camino,longCamino) = eligeCamino(matriz, feromonas,time_constraints)\n",
    "            \n",
    "            if longCamino <= longMejorCamino:\n",
    "                mejorCamino     = camino\n",
    "                longMejorCamino = longCamino\n",
    "                \n",
    "            rastroFeromonas(feromonas, camino, distMedia/longCamino)\n",
    "            # En cualquier caso, las feromonas se van evaporando\n",
    "            evaporaFeromonas(feromonas)\n",
    "             \n",
    "        # Se devuelve el mejor camino que se haya encontrado\n",
    "        return (mejorCamino, longMejorCamino)    \n",
    "    \n",
    "\n",
    "    def calcularTSPTW( archivoProblema, tiempoLimite):\n",
    "        with open(archivoProblema) as config:\n",
    "            flag = False\n",
    "            count =0\n",
    "            matriz=[]\n",
    "            time_constraints=[]\n",
    "            numCity=0\n",
    "            confLines = config.readlines()\n",
    "            for line in confLines:\n",
    "                if flag==False:\n",
    "                    numCity =int(line.strip())\n",
    "                    flag=True\n",
    "                else:\n",
    "                    if count<numCity:\n",
    "                        matriz.append([float(x) for x in line.strip().split()])  \n",
    "                        count+=1\n",
    "                    else: \n",
    "                        time_constraints.append([float(x) for x in line.strip().split()])                       \n",
    "        return matriz,numCity,time_constraints\n",
    "          \n",
    "    \n",
    "    # Ejemplo de uso    \n",
    "    # Generación de una matriz de prueba\n",
    "     \n",
    "    \n",
    "    \n",
    "    ciudades,numCiudades,time_constraints         = calcularTSPTW('data/rc_201.1.txt', 20)\n",
    "    distanciaMaxima  = len(ciudades)\n",
    "    # Obtención del mejor camino, las iteraciones son la cantidad de hormigas que empleamos para resolverlo\n",
    "    iteraciones = 100\n",
    "    distMedia   = numCiudades*distanciaMaxima/2\n",
    "    (camino, longCamino) = hormigas(ciudades, iteraciones, distMedia,time_constraints)\n",
    "    print(\"Camino: \", camino) \n",
    "    print(\"Costo del camino: \", longCamino) \n",
    "     \n",
    "                                "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
